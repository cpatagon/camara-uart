#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
transport_api_robust.py ‚Äî API de transporte UART robusta
- Combina lo mejor del protocolo ACK + mejoras de sincronizaci√≥n
- Elimina la desaceleraci√≥n artificial problem√°tica
- Implementa verificaci√≥n bidireccional real
"""

import time
import struct
import logging
import serial

START_MARKER = b"\xAA" * 10
END_MARKER   = b"\xBB" * 10
END_TEXT     = b"<FIN_TRANSMISION>\r\n"
SIZE_BYTES   = 4
DEFAULT_CHUNK = 512

# Protocolo ACK mejorado
ACK_READY = "ACK_READY"
ACK_OK = "ACK_OK"
ACK_MISSING = "ACK_MISSING:"
ACK_ERROR = "ACK_ERROR"

class UartTransportRobust:
    def __init__(self, port: str, baudrate: int = 57600, timeout: float = 2.0,
                 rtscts: bool = False, xonxoff: bool = False):
        self.port = port
        self.baudrate = baudrate
        self.timeout = timeout
        self.rtscts = rtscts
        self.xonxoff = xonxoff
        self.ser: serial.Serial | None = None

    def connect(self) -> bool:
        try:
            self.ser = serial.Serial(
                port=self.port,
                baudrate=self.baudrate,
                parity=serial.PARITY_NONE,
                stopbits=serial.STOPBITS_ONE,
                bytesize=serial.EIGHTBITS,
                timeout=self.timeout,
                write_timeout=15,
                rtscts=self.rtscts,
                xonxoff=self.xonxoff
            )
            
            # Limpieza inicial mejorada
            for _ in range(5):
                self.ser.reset_input_buffer()
                self.ser.reset_output_buffer()
                time.sleep(0.1)
            
            logging.info(f"‚úÖ UART Robusta: {self.port} @ {self.baudrate} (rtscts={self.rtscts}, xonxoff={self.xonxoff})")
            return True
        except Exception as e:
            logging.error(f"‚ùå UART open: {e}")
            return False

    def close(self):
        try:
            if self.ser and self.ser.is_open:
                # Cierre m√°s suave
                self.ser.flush()
                timeout_start = time.time()
                while self.ser.out_waiting > 0 and (time.time() - timeout_start) < 10:
                    time.sleep(0.1)
                
                self.ser.reset_output_buffer()
                self.ser.reset_input_buffer()
                self.ser.close()
                logging.info("üîå UART robusta cerrada")
        except Exception as e:
            logging.debug(f"Error cerrando UART: {e}")

    def _wait_for_client_ready(self, timeout: float = 30) -> bool:
        """Esperar que el cliente confirme estar listo para recibir"""
        logging.info("üìã Esperando que cliente est√© listo...")
        deadline = time.time() + timeout
        
        while time.time() < deadline:
            try:
                line = self.ser.readline().decode("utf-8", errors="ignore").strip()
                if line == ACK_READY:
                    logging.info("‚úÖ Cliente listo para recibir")
                    return True
                elif line:
                    logging.debug(f"üì® Cliente (esperando ready): {line}")
            except Exception as e:
                logging.debug(f"Error leyendo ready: {e}")
                
            time.sleep(0.1)
        
        logging.warning("‚è∞ Timeout esperando cliente listo")
        return False

    def _wait_for_ack(self, expected_size: int, timeout: float = 45) -> tuple[bool, int]:
        """Esperar ACK del cliente con timeout extendido"""
        logging.info("üìã Esperando confirmaci√≥n final del cliente...")
        deadline = time.time() + timeout
        
        while time.time() < deadline:
            try:
                line = self.ser.readline().decode("utf-8", errors="ignore").strip()
                if not line:
                    continue
                    
                logging.info(f"üì® Cliente: {line}")
                
                if line == ACK_OK:
                    logging.info("‚úÖ ACK_OK - Cliente confirm√≥ recepci√≥n completa")
                    return True, 0
                elif line.startswith(ACK_MISSING):
                    try:
                        received = int(line.split(":")[1])
                        missing = expected_size - received
                        logging.warning(f"‚ö†Ô∏è Faltan {missing} bytes (cliente recibi√≥ {received})")
                        return False, missing
                    except:
                        logging.error("‚ùå Formato ACK_MISSING inv√°lido")
                        return False, expected_size
                elif line == ACK_ERROR:
                    logging.error("‚ùå Cliente report√≥ error")
                    return False, expected_size
                    
            except Exception as e:
                logging.debug(f"Error leyendo ACK: {e}")
                
            time.sleep(0.1)
        
        logging.warning("‚è∞ Timeout esperando ACK final")
        return False, 0

    def _send_missing_bytes(self, data: bytes, start_offset: int, missing_count: int) -> bool:
        """Retransmitir bytes faltantes de manera robusta"""
        if start_offset >= len(data) or missing_count <= 0:
            logging.error(f"‚ùå Par√°metros retransmisi√≥n inv√°lidos: offset={start_offset}, missing={missing_count}")
            return False
            
        end_offset = min(start_offset + missing_count, len(data))
        missing_data = data[start_offset:end_offset]
        
        logging.info(f"üîÑ Retransmitiendo {len(missing_data)} bytes desde offset {start_offset}")
        
        try:
            # Marcador especial para retransmisi√≥n
            retry_marker = b"\xCC" * 4
            self.ser.write(retry_marker)
            self.ser.flush()
            time.sleep(0.1)  # Pausa para que cliente detecte retransmisi√≥n
            
            # Env√≠o con chunks m√°s peque√±os y pausas
            chunk_size = 64  # Chunks muy peque√±os para m√°xima confiabilidad
            sent = 0
            
            while sent < len(missing_data):
                chunk_end = min(sent + chunk_size, len(missing_data))
                chunk = missing_data[sent:chunk_end]
                
                bytes_written = self.ser.write(chunk)
                self.ser.flush()
                sent += bytes_written
                
                # Pausa m√°s larga para estabilidad
                time.sleep(0.02)
                
                if sent % 256 == 0 or sent == len(missing_data):
                    logging.info(f"üîÑ Retransmisi√≥n: {sent}/{len(missing_data)} bytes")
            
            # Pausa final despu√©s de retransmisi√≥n
            time.sleep(0.5)
            logging.info("‚úÖ Retransmisi√≥n completada")
            return True
            
        except Exception as e:
            logging.error(f"‚ùå Error en retransmisi√≥n: {e}")
            return False

    def _calculate_smart_sleep(self, sent_bytes: int, total_bytes: int, base_sleep_ms: int) -> float:
        """Calcular pausa inteligente - SIN desaceleraci√≥n artificial problem√°tica"""
        base_sleep = max(0.001, base_sleep_ms / 1000.0)
        
        # Velocidad constante - eliminamos la desaceleraci√≥n que causaba los chunks de 110ms
        return base_sleep
        
        # NOTA: Comentamos la l√≥gica de desaceleraci√≥n que causaba el problema:
        # if remaining_bytes <= 256: return base_sleep * 25  # ESTO causaba 125ms
        # if remaining_bytes <= 512: return base_sleep * 20  # ESTO causaba 100ms

    def send_bytes_robust(self, data: bytes,
                         chunk_size: int = DEFAULT_CHUNK,
                         inter_chunk_sleep_ms: int = 0,
                         max_retries: int = 2,
                         wait_client_ready: bool = True) -> bool:
        """Env√≠o robusto con protocolo ACK mejorado"""
        if not self.ser or not self.ser.is_open:
            logging.error("‚ùå UART no abierta")
            return False

        size = len(data)
        logging.info(f"üìä Env√≠o ROBUSTO: {size} bytes con protocolo ACK mejorado")

        try:
            # 0. Opcional: Esperar que cliente est√© listo
            if wait_client_ready:
                if not self._wait_for_client_ready(timeout=30):
                    logging.warning("‚ö†Ô∏è Cliente no confirm√≥ estar listo, continuando...")

            # 1. Pre√°mbulo del protocolo
            logging.info("üì§ Enviando pre√°mbulo...")
            self.ser.write(START_MARKER)
            self.ser.flush()
            time.sleep(0.1)  # Pausa fija, no variable
            
            size_bytes = struct.pack(">I", size)
            self.ser.write(size_bytes)
            self.ser.flush()
            time.sleep(0.1)  # Pausa fija, no variable
            
            # 2. Env√≠o principal con velocidad CONSTANTE (sin desaceleraci√≥n)
            logging.info("üì¶ Iniciando env√≠o principal...")
            sent = 0
            view = memoryview(data)
            last_log = 0
            base_sleep = self._calculate_smart_sleep(0, size, inter_chunk_sleep_ms)
            
            while sent < size:
                remaining = size - sent
                current_chunk_size = min(chunk_size, remaining)
                chunk = view[sent:sent + current_chunk_size]
                
                # Env√≠o del chunk
                try:
                    bytes_written = self.ser.write(chunk)
                    if bytes_written != len(chunk):
                        logging.warning(f"‚ö†Ô∏è Escritura parcial: {bytes_written}/{len(chunk)}")
                    
                    self.ser.flush()
                    sent += bytes_written
                    
                except serial.SerialTimeoutException:
                    logging.error(f"‚ùå Timeout escribiendo en byte {sent}")
                    return False
                
                # Pausa CONSTANTE (eliminamos la l√≥gica de desaceleraci√≥n)
                if base_sleep > 0:
                    time.sleep(base_sleep)
                
                # Log de progreso
                pct = int(sent * 100 / size) if size else 100
                if pct - last_log >= 10:
                    logging.info(f"üì¶ Progreso constante: {sent}/{size} bytes ({pct}%)")
                    last_log = pct
            
            # 3. Sincronizaci√≥n final robusta
            logging.info("üîç Sincronizaci√≥n final robusta...")
            self.ser.flush()
            
            # Drenaje con timeout extendido
            drain_start = time.time()
            max_drain_time = 15
            
            while self.ser.out_waiting > 0:
                if time.time() - drain_start > max_drain_time:
                    logging.error(f"‚ùå TIMEOUT drenaje: {self.ser.out_waiting} bytes pendientes")
                    return False
                time.sleep(0.1)
                
                elapsed = time.time() - drain_start
                if int(elapsed) % 3 == 0 and elapsed > 1:
                    logging.info(f"‚è≥ Drenando: {self.ser.out_waiting} bytes ({elapsed:.1f}s)")
            
            # 4. Pausa de estabilizaci√≥n antes de marcadores
            logging.info("‚è≥ Pausa de estabilizaci√≥n...")
            time.sleep(1.0)  # Tiempo fijo para que cliente procese
            
            # 5. Marcadores finales
            self.ser.write(END_MARKER)
            self.ser.flush()
            time.sleep(0.2)
            self.ser.write(END_TEXT)
            self.ser.flush()
            time.sleep(0.2)
            
            logging.info("üì§ Env√≠o completado, iniciando verificaci√≥n ACK...")
            
            # 6. Ciclo de verificaci√≥n y correcci√≥n
            for retry in range(max_retries + 1):
                if retry > 0:
                    logging.info(f"üîÑ Intento de correcci√≥n #{retry}/{max_retries}")
                
                # Esperar ACK con timeout extendido
                ack_success, missing_bytes = self._wait_for_ack(size, timeout=60)
                
                if ack_success:
                    logging.info("üéâ ¬°TRANSMISI√ìN ROBUSTA COMPLETADA CON √âXITO!")
                    return True
                
                if missing_bytes <= 0:
                    logging.error("‚ùå No se pudo determinar correcci√≥n necesaria")
                    break
                
                if retry >= max_retries:
                    logging.error(f"‚ùå M√°ximo de reintentos alcanzado ({max_retries})")
                    break
                
                # Calcular offset y retransmitir
                received_bytes = size - missing_bytes
                success = self._send_missing_bytes(data, received_bytes, missing_bytes)
                
                if not success:
                    logging.error("‚ùå Fall√≥ retransmisi√≥n")
                    break
                    
                # Pausa antes del siguiente ciclo ACK
                time.sleep(1.0)
            
            logging.error("‚ùå Transmisi√≥n fall√≥ despu√©s de todos los reintentos")
            return False
            
        except Exception as e:
            logging.error(f"‚ùå Error cr√≠tico en env√≠o robusto: {e}")
            return False

    # M√©todos de compatibilidad
    def send_bytes(self, data: bytes, **kwargs) -> bool:
        """M√©todo de compatibilidad - redirige al robusto"""
        return self.send_bytes_robust(data, **kwargs)

    def send_file(self, path: str, **kwargs) -> bool:
        """Env√≠o de archivo robusto"""
        with open(path, "rb") as f:
            data = f.read()
        return self.send_bytes_robust(data, **kwargs)
